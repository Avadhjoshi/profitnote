"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DhanFeed = exports.Depth = exports.Quote = exports.Ticker = exports.BSE_FNO = exports.BSE_CURR = exports.MCX = exports.BSE = exports.NSE_CURR = exports.NSE_FNO = exports.NSE = exports.IDX = void 0;
const ws_1 = require("ws");
const buffer_1 = require("buffer");
const types_1 = require("./types");
const WSS_URL = 'wss://api-feed.dhan.co';
exports.IDX = 0;
exports.NSE = 1;
exports.NSE_FNO = 2;
exports.NSE_CURR = 3;
exports.BSE = 4;
exports.MCX = 5;
exports.BSE_CURR = 7;
exports.BSE_FNO = 8;
exports.Ticker = 15;
exports.Quote = 17;
exports.Depth = 19;
const retryInterval = 5000;
class DhanSDKHelper {
    constructor(sdkInstance) {
        this.sdkInstance = sdkInstance;
    }
    async onConnectionEstablished(websocket) {
        if (this.sdkInstance.onConnect) {
            await this.sdkInstance.onConnect(this.sdkInstance);
        }
    }
    async onMessageReceived(response) {
        if (this.sdkInstance.onMessage) {
            await this.sdkInstance.onMessage(this.sdkInstance, response);
        }
    }
    async onClose(websocket, closeStatus = null, closeMsg = null) {
        console.log(`WebSocket closed with status ${closeStatus}: ${closeMsg}`);
        websocket.close();
        this.sdkInstance.ws = null;
    }
}
class DhanFeed {
    constructor(clientId, accessToken, instruments, subscriptionCode, onConnect = null, onMessage = null, onClose = null) {
        this.clientId = clientId;
        this.accessToken = accessToken;
        this.instruments = instruments;
        this.subscriptionCode = subscriptionCode;
        this.onConnect = onConnect;
        this.onMessage = onMessage;
        this.onClose = onClose;
        this.ws = null;
        this.sdkHelper = new DhanSDKHelper(this);
    }
    padWithZeros(buffer, length) {
        if (buffer.length < length) {
            const padding = buffer_1.Buffer.alloc(length - buffer.length, 0);
            return buffer_1.Buffer.concat([buffer, padding]);
        }
        return buffer;
    }
    async authorize() {
        try {
            console.log("Authorizing your token...");
            let apiAccessToken = buffer_1.Buffer.from(this.accessToken, 'utf-8');
            apiAccessToken = this.padWithZeros(apiAccessToken, 500);
            const authenticationType = buffer_1.Buffer.from("2P", 'utf-8');
            const payload = buffer_1.Buffer.concat([apiAccessToken, authenticationType]);
            const feedRequestCode = 11;
            const messageLength = 83 + apiAccessToken.length + authenticationType.length;
            let clientIdBuffer = buffer_1.Buffer.from(this.clientId, 'utf-8');
            clientIdBuffer = this.padWithZeros(clientIdBuffer, 30);
            const dhanAuth = buffer_1.Buffer.alloc(50, 0);
            const header = buffer_1.Buffer.alloc(83);
            header.writeUInt8(feedRequestCode, 0);
            header.writeUInt16LE(messageLength, 1);
            clientIdBuffer.copy(header, 3, 0, 30);
            dhanAuth.copy(header, 33, 0, 50);
            const authorizationPacket = buffer_1.Buffer.concat([header, payload]);
            await this.ws.send(authorizationPacket);
            console.log("Authorization successful!");
        }
        catch (error) {
            console.log(`Authorization failed: ${error}`);
        }
    }
    async connect() {
        if (this.accessToken === '' || this.clientId === '') {
            console.error('Access Token or Client ID is missing');
            return;
        }
        this.ws = new ws_1.WebSocket(WSS_URL, {
            headers: {
                'Authorization': `Bearer ${this.accessToken}`
            }
        });
        this.ws.on('error', (error) => {
            console.error('WebSocket error:', error);
            setTimeout(() => {
                console.log('WEBSOCKET_CLOSE: reconnecting...');
                this.connect();
            }, retryInterval);
        });
        this.ws.on('open', async () => {
            await this.authorize();
            console.log('WebSocket connection established & authorized successfully');
            await this.sdkHelper.onConnectionEstablished(this.ws);
        });
        this.ws.on('message', async (data) => {
            let response;
            const responseCode = data.readUInt8(0);
            switch (responseCode) {
                case 2:
                    response = this.processTickerPacket(data);
                    break;
                case 3:
                    response = this.processMarketDepthPacket(data);
                    break;
                case 4:
                    response = this.processQuotePacket(data);
                    break;
                case 5:
                    response = this.processOIDataPacket(data);
                    break;
                case 6:
                    response = this.processPrevClosePacket(data);
                    break;
                case 7:
                    response = this.processMarketStatusPacket(data);
                    break;
                case 50:
                    this.processServerDisConnectionPacket(data);
                    process.exit();
                    break;
                default:
                    console.warn(`Unknown response code: ${responseCode}`);
                    response = null;
            }
            await this.sdkHelper.onMessageReceived(response);
        });
        this.ws.on('close', async (code, reason) => {
            console.log(`WebSocket closed with code ${code}: ${reason}`);
            await this.sdkHelper.onClose(this.ws, code, reason.toString());
        });
    }
    async close() {
        if (this.ws) {
            this.ws.close();
        }
    }
    async send(payload) {
        if (this.ws) {
            this.ws.send(payload);
        }
    }
    createHeader(feedRequestCode, messageLength, clientId) {
        const header = buffer_1.Buffer.alloc(83);
        header.writeInt16LE(feedRequestCode, 0);
        header.writeInt32LE(messageLength, 2);
        header.write(clientId, 6, 'utf-8');
        return header;
    }
    async subscribeSymbols(feedRequestCode, symbols) {
        const uniqueSymbolsSet = new Set(this.instruments);
        symbols.forEach(symbol => uniqueSymbolsSet.add(symbol));
        this.instruments = Array.from(uniqueSymbolsSet);
        if (this.ws && this.ws.readyState === ws_1.WebSocket.OPEN) {
            const packet = this.createSubscriptionPacket(symbols, feedRequestCode, true);
            await this.send(packet);
        }
    }
    async subscribe(feedRequestCode, symbols) {
        const instruments = this.instruments;
        const partitions = Math.ceil(instruments.length / 100);
        for (let i = 0; i < partitions; i++) {
            const start = i * 100;
            const end = Math.min((i + 1) * 100, instruments.length);
            const symbols = instruments.slice(start, end);
            await this.subscribeSymbols(this.subscriptionCode, symbols);
        }
    }
    createSubscriptionPacket(instruments, feedRequestCode, status) {
        const numInstruments = instruments.length;
        const actualFeedRequestCode = status ? this.subscriptionCode : this.subscriptionCode + 1;
        const header = this.createHeader(actualFeedRequestCode, 83 + 4 + numInstruments * 21, this.clientId);
        const numInstrumentsBytes = buffer_1.Buffer.alloc(4);
        numInstrumentsBytes.writeInt32LE(numInstruments, 0);
        let instrumentInfo = buffer_1.Buffer.alloc(0);
        instruments.forEach(([exchangeSegment, securityId]) => {
            const segmentBuffer = buffer_1.Buffer.alloc(1);
            segmentBuffer.writeUInt8(exchangeSegment, 0);
            const securityIdBuffer = buffer_1.Buffer.alloc(20);
            securityIdBuffer.write(securityId, 0, 'utf-8');
            instrumentInfo = buffer_1.Buffer.concat([instrumentInfo, segmentBuffer, securityIdBuffer]);
        });
        const padding = buffer_1.Buffer.alloc((100 - numInstruments) * 21);
        instrumentInfo = buffer_1.Buffer.concat([instrumentInfo, padding]);
        const subscriptionPacket = buffer_1.Buffer.concat([header, numInstrumentsBytes, instrumentInfo]);
        return subscriptionPacket;
    }
    async unsubscribe(feedRequestCode, symbols) {
        this.instruments = this.instruments.filter(instrument => !symbols.some(symbol => symbol[0] === instrument[0] && symbol[1] === instrument[1]));
        if (this.ws && this.ws.readyState === ws_1.WebSocket.OPEN) {
            console.log("Unsubscribing from:", symbols);
            const unsubscribePacket = this.createUnsubscribePacket(feedRequestCode, symbols);
            await this.send(unsubscribePacket);
            console.log("Remaining subscribed instruments:", this.instruments);
        }
    }
    createUnsubscribePacket(feedRequestCode, instruments) {
        const numInstruments = instruments.length;
        const unsubscribeCode = feedRequestCode + 1; // Assuming unsubscribe code is feedRequestCode + 1
        const header = this.createHeader(unsubscribeCode, 83 + 4 + numInstruments * 21, this.clientId);
        const numInstrumentsBytes = buffer_1.Buffer.alloc(4);
        numInstrumentsBytes.writeInt32LE(numInstruments, 0);
        let instrumentInfo = buffer_1.Buffer.alloc(0);
        instruments.forEach(([exchangeSegment, securityId]) => {
            const segmentBuffer = buffer_1.Buffer.alloc(1);
            segmentBuffer.writeUInt8(exchangeSegment, 0);
            const securityIdBuffer = buffer_1.Buffer.alloc(20);
            securityIdBuffer.write(securityId, 0, 'utf-8');
            instrumentInfo = buffer_1.Buffer.concat([instrumentInfo, segmentBuffer, securityIdBuffer]);
        });
        const padding = buffer_1.Buffer.alloc((100 - numInstruments) * 21);
        instrumentInfo = buffer_1.Buffer.concat([instrumentInfo, padding]);
        return buffer_1.Buffer.concat([header, numInstrumentsBytes, instrumentInfo]);
    }
    processTickerPacket(data) {
        if (data.length >= 16) {
            const responseCode = data.readUInt8(0);
            const exchangeSegment = data.readUInt8(1);
            const securityId = data.readUInt32LE(4);
            const ltp = data.readFloatLE(8);
            const ltt = data.readUInt32LE(12);
            const tickerResponse = new types_1.TickerResponse('Ticker Packet', responseCode, exchangeSegment, securityId, Number(ltp.toFixed(2)), new Date(ltt * 1000).toISOString());
            return tickerResponse;
        }
    }
    processPrevClosePacket(data) {
        if (data.length >= 16) {
            const responseCode = data.readUInt8(0);
            const exchangeSegment = data.readUInt8(1);
            const securityId = data.readUInt32LE(4);
            const prevClosePrice = data.readFloatLE(8);
            const prevOpenInterest = data.readUInt32LE(12);
            const prevCloseResponse = new types_1.PrevCloseResponse('Prev Close Packet', responseCode, exchangeSegment, securityId, Number(prevClosePrice.toFixed(2)), prevOpenInterest);
            return prevCloseResponse;
        }
    }
    processMarketStatusPacket(data) {
        if (data.length >= 1) {
            const responseCode = data.readUInt8(0);
            const status = responseCode === 7 ? 'Market Open' : 'Market Close';
            const marketStatusResponse = new types_1.MarketStatusResponse('Market Status Packet', responseCode, status);
            return marketStatusResponse;
        }
    }
    processQuotePacket(data) {
        if (data.length >= 50) {
            const quoteResponse = new types_1.QuoteResponse('Quote Packet', data.readUInt8(0), data.readUInt32LE(4), data.readFloatLE(8), data.readUInt16LE(12), new Date(data.readUInt32LE(14) * 1000).toISOString(), data.readFloatLE(18), data.readUInt32LE(22), data.readUInt32LE(26), data.readUInt32LE(30), data.readFloatLE(34), data.readFloatLE(38), data.readFloatLE(42), data.readFloatLE(46));
            return quoteResponse;
        }
    }
    processOIDataPacket(data) {
        if (data.length >= 12) {
            const oiData = new types_1.OiDataResponse('OI Data Packet', data.readUInt8(0), data.readUInt8(1), data.readUInt32LE(4), data.readUInt32LE(8));
            return oiData;
        }
    }
    processMarketDepthPacket(data) {
        const headerLength = 13;
        const depthLevelSize = 20;
        const maxDepthLevels = 5;
        if (data.length < headerLength) {
            console.warn('Market Depth packet data is too short for header');
            return;
        }
        const result = new types_1.MarketDepthResponse('Market Depth Packet', data.readUInt8(0), data.readFloatLE(8), []);
        for (let i = 0; i < 5; i++) {
            let offset = headerLength + i * depthLevelSize;
            offset = offset - 1;
            if (offset + depthLevelSize > data.length)
                break;
            const depthLevel = new types_1.DepthLevel(data.readInt16LE(offset + 8), data.readInt32LE(offset), data.readFloatLE(offset + 12), data.readFloatLE(offset + 16), data.readInt32LE(offset + 4), data.readInt16LE(offset + 10));
            result.depthLevels.push(depthLevel);
        }
        if (data.length < headerLength + maxDepthLevels * depthLevelSize) {
            console.warn(`Market Depth packet data is shorter than expected. Expected at least ${headerLength + maxDepthLevels * depthLevelSize} bytes, received ${data.length} bytes.`);
        }
        return result;
    }
    processServerDisConnectionPacket(data) {
        const errorCode = data.readUInt16LE(8);
        switch (errorCode) {
            case 805:
                console.log("Connection limit exceeded, Please close existing connection to create new connection");
                break;
            case 806:
                console.log("Data APIs not subscribed, Please subscribe tp continue using Market Feed APIs");
                break;
            case 807:
                console.log("Access token is expired, Please generate new access token");
                break;
            case 808:
                console.log("Authentication Failed - Check Client ID and Access Token");
                break;
            case 809:
                console.log("Access token is invalid or not found, Please generate new access token");
                break;
            default:
                console.log("Disconnected: Unknown reason for disconnection");
        }
        this.close();
    }
}
exports.DhanFeed = DhanFeed;
